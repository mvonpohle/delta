<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>delta.ml.config_parser API documentation</title>
<meta name="description" content="Functions to support loading custom ML-related objects from dictionaries specified
in yaml files. Includes constructing custom neural networks and more." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>delta.ml.config_parser</code></h1>
</header>
<section id="section-intro">
<p>Functions to support loading custom ML-related objects from dictionaries specified
in yaml files. Includes constructing custom neural networks and more.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright Â© 2020, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All rights reserved.
#
# The DELTA (Deep Earth Learning, Tools, and Analysis) platform is
# licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
Functions to support loading custom ML-related objects from dictionaries specified
in yaml files. Includes constructing custom neural networks and more.
&#34;&#34;&#34;
from collections.abc import Mapping
import copy
import functools
from typing import Callable, List, Union

from packaging import version
import tensorflow
import tensorflow.keras.layers #pylint: disable=no-name-in-module
import tensorflow.keras.losses #pylint: disable=no-name-in-module
from tensorflow.python.keras.utils import losses_utils #pylint: disable=no-name-in-module
import tensorflow.keras.models #pylint: disable=no-name-in-module

from delta.config import config
import delta.config.extensions as extensions

class _LayerWrapper:
    def __init__(self, layer_type, layer_name, inputs, params, all_layers):
        &#34;&#34;&#34;
        all_layers is a name indexed dictionary of LayerWrappers for all the layers,
        shared between them.
        &#34;&#34;&#34;
        self._layer_type = layer_type
        self.name = layer_name
        self._inputs = inputs
        lc = extensions.layer(layer_type)
        if lc is None:
            lc = getattr(tensorflow.keras.layers, layer_type, None)
        if lc is None:
            raise ValueError(&#39;Unknown layer type %s.&#39; % (layer_type))
        self.layer = lc(**params)
        self._sub_layers = None
        self._tensor = None
        all_layers[layer_name] = self
        self._all_layers = all_layers

    def is_input(self):
        return self._layer_type == &#39;Input&#39;

    def sub_layer(self, name):
        assert self._sub_layers, &#39;Layer %s does not support sub-layers.&#39; % (self.layer.name)
        assert name in self._sub_layers, (&#39;Layer %s not found in &#39; % (name)) + str(self._sub_layers)
        return self._sub_layers[name]

    # TODO: will crash if there is a cycle in the graph
    def output_tensor(self):
        &#34;&#34;&#34;
        Constructs the output tensor with preceding layers as inputs.
        &#34;&#34;&#34;
        if self._tensor is not None:
            return self._tensor
        inputs = []
        for k in self._inputs:
            if isinstance(k, tensorflow.Tensor):
                inputs.append(k)
                continue
            if isinstance(k, int) or &#39;/&#39; not in k:
                l = self._all_layers[k].output_tensor()
                inputs.append(l)
                continue
            # getting nested layer
            parts = k.split(&#39;/&#39;)
            input_layer = parts[0]
            if input_layer not in self._all_layers:
                raise ValueError(&#39;Input layer &#39; + str(input_layer) + &#39; not found.&#39;)
            self._all_layers[input_layer].output_tensor() # compute it if it hasn&#39;t been
            cur = self._all_layers[input_layer].sub_layer(k[len(parts[0]) + 1:])

            if isinstance(self._tensor, tensorflow.keras.layers.Layer):
                inputs.append(cur.output)
            else:
                inputs.append(cur)
        if inputs:
            if len(inputs) == 1:
                inputs = inputs[0]
            self._tensor = self.layer(inputs)
            if isinstance(self._tensor, tuple):
                self._sub_layers = self._tensor[1]
                self._tensor = self._tensor[0]
            if isinstance(self._tensor, tensorflow.keras.layers.Layer):
                self._tensor = self._tensor.output
        else:
            self._tensor = self.layer
        return self._tensor

def _make_layer(layer_dict, layer_id, prev_layer, all_layers):
    &#34;&#34;&#34;
    Constructs a layer specified in layer_dict.
    layer_id is the order in the order in the config file.
    Assumes layer_dict only contains the key which is the
    layer type, mapped to a sub-dict with properly named parameters for constructing
    the layer, and the additional fields:

     * `name` (optional): a name to refer to the layer by
     * `inputs` (optional): the name or a list of names of
       the preceding layers (defaults to previous in list)
    &#34;&#34;&#34;
    if len(layer_dict.keys()) &gt; 1:
        raise ValueError(&#39;Layer with multiple types.&#39;)
    layer_type = next(layer_dict.keys().__iter__())
    l = layer_dict[layer_type]
    if l is None:
        l = {}

    inputs = [prev_layer]
    if layer_type == &#39;Input&#39;:
        inputs = []
    if &#39;name&#39; in l:
        layer_id = l[&#39;name&#39;]
    if &#39;inputs&#39; in l:
        inputs = l[&#39;inputs&#39;]
        l = copy.copy(l) # don&#39;t modify original dict
        del l[&#39;inputs&#39;]
        if isinstance(inputs, (int, str)):
            inputs = [inputs]

    return _LayerWrapper(layer_type, layer_id, inputs, l, all_layers)

def _make_model(layer_list):
    &#34;&#34;&#34;
    Makes a model from a list of layers.
    &#34;&#34;&#34;
    assert layer_list is not None, &#39;No model specified!&#39;

    prev_layer = 0
    last = None
    all_layers = {}
    for (i, l) in enumerate(layer_list):
        last = _make_layer(l, i, prev_layer, all_layers)
        prev_layer = last.name

    outputs = last.output_tensor()
    inputs = [l.output_tensor() for l in all_layers.values() if l.is_input()]

    if len(inputs) == 1:
        inputs = inputs[0]
    return tensorflow.keras.models.Model(inputs=inputs, outputs=outputs)

def _apply_params(model_dict, exposed_params):
    &#34;&#34;&#34;
    Apply the parameters in exposed_params and in model_dict[&#39;params&#39;]
    to the fields in model_dict, returning a copy.
    &#34;&#34;&#34;
    defined_params = {}
    if &#39;params&#39; in model_dict and model_dict[&#39;params&#39;] is not None:
        defined_params = model_dict[&#39;params&#39;]

    params = {**exposed_params, **defined_params}
    # replace parameters recursively in all layers
    def recursive_dict_list_apply(d, func):
        if isinstance(d, Mapping):
            for k, v in d.items():
                d[k] = recursive_dict_list_apply(v, func)
            return d
        if isinstance(d, list):
            return list(map(functools.partial(recursive_dict_list_apply, func=func), d))
        if isinstance(d, str):
            return func(d)
        return d
    def apply_params(s):
        for (k, v) in params.items():
            if s == k:
                return v
        return s
    model_dict_copy = copy.deepcopy(model_dict)
    recursive_dict_list_apply(model_dict_copy, apply_params)

    # checks if the first layer is an Input, if not insert one
    layer_list = model_dict_copy[&#39;layers&#39;]
    assert layer_list is not None, &#39;No model specified!&#39;
    first_layer_type = next(layer_list[0].keys().__iter__())
    if first_layer_type != &#39;Input&#39; and &#39;input&#39; not in layer_list[0][first_layer_type]:
        model_dict_copy[&#39;layers&#39;] = [{&#39;Input&#39; : {&#39;shape&#39; : params[&#39;in_shape&#39;]}}] + layer_list

    return model_dict_copy

def model_from_dict(model_dict: dict, exposed_params: dict) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Construct a model.

    Parameters
    ----------
    model_dict: dict
        Config dictionary describing the model
    exposed_params: dict
        Dictionary of parameter names and values to substitute.

    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]:
        Model constructor function.
    &#34;&#34;&#34;
    model_dict = _apply_params(model_dict, exposed_params)
    return functools.partial(_make_model, model_dict[&#39;layers&#39;])

def _parse_str_or_dict(spec, type_name):
    if isinstance(spec, str):
        return (spec, {})
    if isinstance(spec, dict):
        assert len(spec.keys()) == 1, &#39;Only one %s may be specified.&#39; % (type_name)
        name = list(spec.keys())[0]
        return (name, spec[name])
    raise ValueError(&#39;Unexpected entry for %s.&#39; % (type_name))

def loss_from_dict(loss_spec: Union[dict, str]) -&gt; tensorflow.keras.losses.Loss:
    &#34;&#34;&#34;
    Construct a loss function.

    Parameters
    ----------
    loss_spec: Union[dict, str]
        Specification of the loss function.  Either a string that is compatible
        with the keras interface (e.g. &#39;categorical_crossentropy&#39;) or an object defined by a dict
        of the form {&#39;LossFunctionName&#39;: {&#39;arg1&#39;:arg1_val, ...,&#39;argN&#39;,argN_val}}

    Returns
    -------
    tensorflow.keras.losses.Loss
        The loss object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(loss_spec, &#39;loss function&#39;)
    lc = extensions.loss(name)
    if lc is None:
        lc = getattr(tensorflow.keras.losses, name, None)
    if lc is None:
        raise ValueError(&#39;Unknown loss type %s.&#39; % (name))
    if isinstance(lc, type) and issubclass(lc, tensorflow.keras.losses.Loss):
        # older versions do not support AUTO. Not sure of exact version, needed for 2.1, works with 2.6
        if version.parse(tensorflow.__version__) &lt; version.parse(&#34;2.2&#34;):
            params[&#39;reduction&#39;] = losses_utils.ReductionV2.SUM
        lc = lc(**params)
    return lc

def metric_from_dict(metric_spec: Union[dict, str]) -&gt; tensorflow.keras.metrics.Metric:
    &#34;&#34;&#34;
    Construct a metric.

    Parameters
    ----------
    metric_spec: Union[dict, str]
        Config dictionary or string defining the metric

    Returns
    -------
    tensorflow.keras.metrics.Metric
        The metric object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(metric_spec, &#39;metric&#39;)
    mc = extensions.metric(name)
    if mc is None:
        mc = getattr(tensorflow.keras.metrics, name, None)
    if mc is None:
        try:
            mc = loss_from_dict(metric_spec)
        except ValueError as v:
            raise ValueError(&#39;Unknown metric %s.&#39; % (name)) from v
    if isinstance(mc, type) and issubclass(mc, tensorflow.keras.metrics.Metric):
        mc = mc(**params)
    return mc

def learning_rate_from_dict(spec: Union[dict, float]) -&gt; \
        Union[tensorflow.keras.optimizers.schedules.LearningRateSchedule, float]:
    &#34;&#34;&#34;
    Construct a learning rate schedule from a dictionary or float.

    Parameters
    ----------
    spec: Union[dict, float]
        Config dictionary  or float defining a learning rate.

    Returns
    -------
    Union[tensorflow.keras.schedules.LearingRateSchedule, float]
        The learning rate schedule or constant learning rate
    &#34;&#34;&#34;
    if isinstance(spec, float):
        return spec
    assert isinstance(spec, dict), &#39;Only dict or float supported for learning rate.&#39;
    assert len(spec.keys()) == 1, &#39;Only one learning rate may be specified.&#39;
    name = list(spec.keys())[0]
    lc = getattr(tensorflow.keras.optimizers.schedules, name, None)
    if lc is None:
        raise ValueError(&#39;Unknown learning rate scheduler %s.&#39; % (name))
    return lc(**spec[name])

def optimizer_from_dict(spec: Union[dict, str]) -&gt; tensorflow.keras.optimizers.Optimizer:
    &#34;&#34;&#34;
    Construct an optimizer from a dictionary or string.

    Parameters
    ----------
    spec: Union[dict, str]
        Config dictionary  or string defining an optimizer

    Returns
    -------
    tensorflow.keras.optimizers.Optimizer
        The optimizer object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(spec, &#39;optimizer&#39;)
    if &#39;learning_rate&#39; in params:
        params[&#39;learning_rate&#39;] = learning_rate_from_dict(params[&#39;learning_rate&#39;])
    mc = getattr(tensorflow.keras.optimizers, name, None)
    if mc is None:
        raise ValueError(&#39;Unknown optimizer %s.&#39; % (name))
    return mc(**params)

def callback_from_dict(callback_dict: Union[dict, str]) -&gt; tensorflow.keras.callbacks.Callback:
    &#34;&#34;&#34;
    Construct a callback from a dictionary.

    Parameters
    ----------
    callback_dict: Union[dict, str]
        Config dictionary defining a callback.

    Returns
    -------
    tensorflow.keras.callbacks.Callback
        The callback object.
    &#34;&#34;&#34;
    assert len(callback_dict.keys()) == 1, f&#39;Error: Callback has more than one type {callback_dict.keys()}&#39;

    cb_type = next(iter(callback_dict.keys()))
    callback_class = extensions.callback(cb_type)
    if callback_class is None:
        callback_class = getattr(tensorflow.keras.callbacks, cb_type, None)
    if callback_dict[cb_type] is None:
        callback_dict[cb_type] = {}
    if callback_class is None:
        raise ValueError(&#39;Unknown callback %s.&#39; % (cb_type))
    return callback_class(**callback_dict[cb_type])

def augmentation_from_dict(aug_dict: Union[dict, str]):
    &#34;&#34;&#34;
    Construct an augmenation function from a dictionary.

    Parameters
    ----------
    aug_dict: Union[dict, str]
        Config dictionary defining an augmentation.

    Returns
    -------
    Callable
        The augmentation function.
    &#34;&#34;&#34;
    if isinstance(aug_dict, str):
        aug_type = aug_dict
        params = {}
    else:
        assert len(aug_dict.keys()) == 1, f&#39;Error: augmentation has more than one type {aug_dict.keys()}&#39;
        aug_type = next(iter(aug_dict.keys()))
        params = aug_dict[aug_type]
        if params is None:
            params = {}
    aug_class = extensions.augmentation(aug_type)
    if aug_class is None:
        raise ValueError(&#39;Unknown augmentation %s.&#39; % (aug_type))
    return aug_class(**params)

def config_callbacks() -&gt; List[tensorflow.keras.callbacks.Callback]:
    &#34;&#34;&#34;
    Returns
    -------
    List[tensorflow.keras.callbacks.Callback]
        List of callbacks specified in the config file.
    &#34;&#34;&#34;
    if not config.train.callbacks() is None:
        return [callback_from_dict(callback) for callback in config.train.callbacks()]
    return []

def config_model(num_bands: int) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]
        A function to construct the model given in the config file.
    &#34;&#34;&#34;
    params_exposed = {&#39;num_classes&#39; : len(config.dataset.classes),
                      &#39;num_bands&#39; : num_bands}

    return model_from_dict(config.train.network.to_dict(), params_exposed)

def config_augmentation():
    &#34;&#34;&#34;
    Returns
    -------
    Callable
        Augmentation function that applies all augmentations in configuration.
    &#34;&#34;&#34;
    augs = config.train.augmentations()
    if augs is None:
        return None
    assert isinstance(augs, list), &#39;Augmentations must be a list.&#39;
    func = None
    for a in augs:
        f = augmentation_from_dict(a)
        func = f if func is None else (lambda f1, f2: lambda x, y: f1(*f2(x, y)))(f, func)
    return func</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="delta.ml.config_parser.augmentation_from_dict"><code class="name flex">
<span>def <span class="ident">augmentation_from_dict</span></span>(<span>aug_dict:Â Union[dict,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an augmenation function from a dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aug_dict</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary defining an augmentation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The augmentation function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def augmentation_from_dict(aug_dict: Union[dict, str]):
    &#34;&#34;&#34;
    Construct an augmenation function from a dictionary.

    Parameters
    ----------
    aug_dict: Union[dict, str]
        Config dictionary defining an augmentation.

    Returns
    -------
    Callable
        The augmentation function.
    &#34;&#34;&#34;
    if isinstance(aug_dict, str):
        aug_type = aug_dict
        params = {}
    else:
        assert len(aug_dict.keys()) == 1, f&#39;Error: augmentation has more than one type {aug_dict.keys()}&#39;
        aug_type = next(iter(aug_dict.keys()))
        params = aug_dict[aug_type]
        if params is None:
            params = {}
    aug_class = extensions.augmentation(aug_type)
    if aug_class is None:
        raise ValueError(&#39;Unknown augmentation %s.&#39; % (aug_type))
    return aug_class(**params)</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.callback_from_dict"><code class="name flex">
<span>def <span class="ident">callback_from_dict</span></span>(<span>callback_dict:Â Union[dict,Â str]) â>Â keras.callbacks.Callback</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a callback from a dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>callback_dict</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary defining a callback.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.callbacks.Callback</code></dt>
<dd>The callback object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callback_from_dict(callback_dict: Union[dict, str]) -&gt; tensorflow.keras.callbacks.Callback:
    &#34;&#34;&#34;
    Construct a callback from a dictionary.

    Parameters
    ----------
    callback_dict: Union[dict, str]
        Config dictionary defining a callback.

    Returns
    -------
    tensorflow.keras.callbacks.Callback
        The callback object.
    &#34;&#34;&#34;
    assert len(callback_dict.keys()) == 1, f&#39;Error: Callback has more than one type {callback_dict.keys()}&#39;

    cb_type = next(iter(callback_dict.keys()))
    callback_class = extensions.callback(cb_type)
    if callback_class is None:
        callback_class = getattr(tensorflow.keras.callbacks, cb_type, None)
    if callback_dict[cb_type] is None:
        callback_dict[cb_type] = {}
    if callback_class is None:
        raise ValueError(&#39;Unknown callback %s.&#39; % (cb_type))
    return callback_class(**callback_dict[cb_type])</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.config_augmentation"><code class="name flex">
<span>def <span class="ident">config_augmentation</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>Augmentation function that applies all augmentations in configuration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_augmentation():
    &#34;&#34;&#34;
    Returns
    -------
    Callable
        Augmentation function that applies all augmentations in configuration.
    &#34;&#34;&#34;
    augs = config.train.augmentations()
    if augs is None:
        return None
    assert isinstance(augs, list), &#39;Augmentations must be a list.&#39;
    func = None
    for a in augs:
        f = augmentation_from_dict(a)
        func = f if func is None else (lambda f1, f2: lambda x, y: f1(*f2(x, y)))(f, func)
    return func</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.config_callbacks"><code class="name flex">
<span>def <span class="ident">config_callbacks</span></span>(<span>) â>Â List[keras.callbacks.Callback]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>List[tensorflow.keras.callbacks.Callback]</code></dt>
<dd>List of callbacks specified in the config file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_callbacks() -&gt; List[tensorflow.keras.callbacks.Callback]:
    &#34;&#34;&#34;
    Returns
    -------
    List[tensorflow.keras.callbacks.Callback]
        List of callbacks specified in the config file.
    &#34;&#34;&#34;
    if not config.train.callbacks() is None:
        return [callback_from_dict(callback) for callback in config.train.callbacks()]
    return []</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.config_model"><code class="name flex">
<span>def <span class="ident">config_model</span></span>(<span>num_bands:Â int) â>Â Callable[[],Â keras.engine.training.Model]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[], tensorflow.keras.models.Model]</code></dt>
<dd>A function to construct the model given in the config file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_model(num_bands: int) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]
        A function to construct the model given in the config file.
    &#34;&#34;&#34;
    params_exposed = {&#39;num_classes&#39; : len(config.dataset.classes),
                      &#39;num_bands&#39; : num_bands}

    return model_from_dict(config.train.network.to_dict(), params_exposed)</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.learning_rate_from_dict"><code class="name flex">
<span>def <span class="ident">learning_rate_from_dict</span></span>(<span>spec:Â Union[dict,Â float]) â>Â Union[keras.optimizers.schedules.learning_rate_schedule.LearningRateSchedule,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a learning rate schedule from a dictionary or float.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>Union[dict, float]</code></dt>
<dd>Config dictionary
or float defining a learning rate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[tensorflow.keras.schedules.LearingRateSchedule, float]</code></dt>
<dd>The learning rate schedule or constant learning rate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def learning_rate_from_dict(spec: Union[dict, float]) -&gt; \
        Union[tensorflow.keras.optimizers.schedules.LearningRateSchedule, float]:
    &#34;&#34;&#34;
    Construct a learning rate schedule from a dictionary or float.

    Parameters
    ----------
    spec: Union[dict, float]
        Config dictionary  or float defining a learning rate.

    Returns
    -------
    Union[tensorflow.keras.schedules.LearingRateSchedule, float]
        The learning rate schedule or constant learning rate
    &#34;&#34;&#34;
    if isinstance(spec, float):
        return spec
    assert isinstance(spec, dict), &#39;Only dict or float supported for learning rate.&#39;
    assert len(spec.keys()) == 1, &#39;Only one learning rate may be specified.&#39;
    name = list(spec.keys())[0]
    lc = getattr(tensorflow.keras.optimizers.schedules, name, None)
    if lc is None:
        raise ValueError(&#39;Unknown learning rate scheduler %s.&#39; % (name))
    return lc(**spec[name])</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.loss_from_dict"><code class="name flex">
<span>def <span class="ident">loss_from_dict</span></span>(<span>loss_spec:Â Union[dict,Â str]) â>Â keras.losses.Loss</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a loss function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loss_spec</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Specification of the loss function.
Either a string that is compatible
with the keras interface (e.g. 'categorical_crossentropy') or an object defined by a dict
of the form {'LossFunctionName': {'arg1':arg1_val, &hellip;,'argN',argN_val}}</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.losses.Loss</code></dt>
<dd>The loss object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loss_from_dict(loss_spec: Union[dict, str]) -&gt; tensorflow.keras.losses.Loss:
    &#34;&#34;&#34;
    Construct a loss function.

    Parameters
    ----------
    loss_spec: Union[dict, str]
        Specification of the loss function.  Either a string that is compatible
        with the keras interface (e.g. &#39;categorical_crossentropy&#39;) or an object defined by a dict
        of the form {&#39;LossFunctionName&#39;: {&#39;arg1&#39;:arg1_val, ...,&#39;argN&#39;,argN_val}}

    Returns
    -------
    tensorflow.keras.losses.Loss
        The loss object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(loss_spec, &#39;loss function&#39;)
    lc = extensions.loss(name)
    if lc is None:
        lc = getattr(tensorflow.keras.losses, name, None)
    if lc is None:
        raise ValueError(&#39;Unknown loss type %s.&#39; % (name))
    if isinstance(lc, type) and issubclass(lc, tensorflow.keras.losses.Loss):
        # older versions do not support AUTO. Not sure of exact version, needed for 2.1, works with 2.6
        if version.parse(tensorflow.__version__) &lt; version.parse(&#34;2.2&#34;):
            params[&#39;reduction&#39;] = losses_utils.ReductionV2.SUM
        lc = lc(**params)
    return lc</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.metric_from_dict"><code class="name flex">
<span>def <span class="ident">metric_from_dict</span></span>(<span>metric_spec:Â Union[dict,Â str]) â>Â keras.metrics.base_metric.Metric</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a metric.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metric_spec</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary or string defining the metric</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.metrics.Metric</code></dt>
<dd>The metric object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metric_from_dict(metric_spec: Union[dict, str]) -&gt; tensorflow.keras.metrics.Metric:
    &#34;&#34;&#34;
    Construct a metric.

    Parameters
    ----------
    metric_spec: Union[dict, str]
        Config dictionary or string defining the metric

    Returns
    -------
    tensorflow.keras.metrics.Metric
        The metric object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(metric_spec, &#39;metric&#39;)
    mc = extensions.metric(name)
    if mc is None:
        mc = getattr(tensorflow.keras.metrics, name, None)
    if mc is None:
        try:
            mc = loss_from_dict(metric_spec)
        except ValueError as v:
            raise ValueError(&#39;Unknown metric %s.&#39; % (name)) from v
    if isinstance(mc, type) and issubclass(mc, tensorflow.keras.metrics.Metric):
        mc = mc(**params)
    return mc</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.model_from_dict"><code class="name flex">
<span>def <span class="ident">model_from_dict</span></span>(<span>model_dict:Â dict, exposed_params:Â dict) â>Â Callable[[],Â keras.engine.training.Model]</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Config dictionary describing the model</dd>
<dt><strong><code>exposed_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of parameter names and values to substitute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[], tensorflow.keras.models.Model]:</code></dt>
<dd>Model constructor function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_from_dict(model_dict: dict, exposed_params: dict) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Construct a model.

    Parameters
    ----------
    model_dict: dict
        Config dictionary describing the model
    exposed_params: dict
        Dictionary of parameter names and values to substitute.

    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]:
        Model constructor function.
    &#34;&#34;&#34;
    model_dict = _apply_params(model_dict, exposed_params)
    return functools.partial(_make_model, model_dict[&#39;layers&#39;])</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.optimizer_from_dict"><code class="name flex">
<span>def <span class="ident">optimizer_from_dict</span></span>(<span>spec:Â Union[dict,Â str]) â>Â keras.optimizers.optimizer_v2.optimizer_v2.OptimizerV2</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an optimizer from a dictionary or string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary
or string defining an optimizer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.optimizers.Optimizer</code></dt>
<dd>The optimizer object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimizer_from_dict(spec: Union[dict, str]) -&gt; tensorflow.keras.optimizers.Optimizer:
    &#34;&#34;&#34;
    Construct an optimizer from a dictionary or string.

    Parameters
    ----------
    spec: Union[dict, str]
        Config dictionary  or string defining an optimizer

    Returns
    -------
    tensorflow.keras.optimizers.Optimizer
        The optimizer object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(spec, &#39;optimizer&#39;)
    if &#39;learning_rate&#39; in params:
        params[&#39;learning_rate&#39;] = learning_rate_from_dict(params[&#39;learning_rate&#39;])
    mc = getattr(tensorflow.keras.optimizers, name, None)
    if mc is None:
        raise ValueError(&#39;Unknown optimizer %s.&#39; % (name))
    return mc(**params)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="delta.ml" href="index.html">delta.ml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="delta.ml.config_parser.augmentation_from_dict" href="#delta.ml.config_parser.augmentation_from_dict">augmentation_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.callback_from_dict" href="#delta.ml.config_parser.callback_from_dict">callback_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.config_augmentation" href="#delta.ml.config_parser.config_augmentation">config_augmentation</a></code></li>
<li><code><a title="delta.ml.config_parser.config_callbacks" href="#delta.ml.config_parser.config_callbacks">config_callbacks</a></code></li>
<li><code><a title="delta.ml.config_parser.config_model" href="#delta.ml.config_parser.config_model">config_model</a></code></li>
<li><code><a title="delta.ml.config_parser.learning_rate_from_dict" href="#delta.ml.config_parser.learning_rate_from_dict">learning_rate_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.loss_from_dict" href="#delta.ml.config_parser.loss_from_dict">loss_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.metric_from_dict" href="#delta.ml.config_parser.metric_from_dict">metric_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.model_from_dict" href="#delta.ml.config_parser.model_from_dict">model_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.optimizer_from_dict" href="#delta.ml.config_parser.optimizer_from_dict">optimizer_from_dict</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>