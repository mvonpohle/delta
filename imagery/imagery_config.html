<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>delta.imagery.imagery_config API documentation</title>
<meta name="description" content="Configuration options specific to imagery." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>delta.imagery.imagery_config</code></h1>
</header>
<section id="section-intro">
<p>Configuration options specific to imagery.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright Â© 2020, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All rights reserved.
#
# The DELTA (Deep Earth Learning, Tools, and Analysis) platform is
# licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
Configuration options specific to imagery.
&#34;&#34;&#34;
import os
import os.path
import numpy as np

import appdirs

from delta.config import config, DeltaConfigComponent, validate_path, validate_positive
from delta.config.extensions import image_reader, preprocess_function
from . import disk_folder_cache


class ImageSet:
    &#34;&#34;&#34;
    Specifies a set of image files.

    The images can be accessed by using the `ImageSet` as an iterable.
    &#34;&#34;&#34;
    def __init__(self, images, image_type, preprocess=None, nodata_value=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        images: Iterator[str]
            Image filenames
        image_type: str
            The image type as a string (i.e., tiff, worldview, landsat). Must have
            been previously registered with `delta.config.extensions.register_image_reader`.
        preprocess: Callable
            Optional preprocessing function to apply to the image
            following the signature in `delta.imagery.delta_image.DeltaImage.set_preprocess`.
        nodata_value: image dtype
            A no data value for pixels to disregard
        &#34;&#34;&#34;
        self._images = images
        self._image_type = image_type
        self._preprocess = preprocess
        self._nodata_value = nodata_value

    def type(self):
        &#34;&#34;&#34;
        Returns
        -------
        str:
            The type of the image
        &#34;&#34;&#34;
        return self._image_type
    def preprocess(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable:
            The preprocessing function
        &#34;&#34;&#34;
        return self._preprocess
    def nodata_value(self):
        &#34;&#34;&#34;
        Returns
        -------
        image dtype:
            Value of pixels to disregard.
        &#34;&#34;&#34;
        return self._nodata_value

    def set_nodata_value(self, nodata):
        &#34;&#34;&#34;
        Set the pixel value to disregard.

        Parameters
        ----------
        nodata: image dtype
            The pixel value to set as nodata
        &#34;&#34;&#34;
        self._nodata_value = nodata

    def load(self, index):
        &#34;&#34;&#34;
        Loads the image of the given index.

        Parameters
        ----------
        index: int
            Index of the image to load.

        Returns
        -------
        `delta.imagery.delta_image.DeltaImage`:
            The image
        &#34;&#34;&#34;
        img = image_reader(self.type())(self[index], self.nodata_value())
        if self._preprocess:
            img.set_preprocess(self._preprocess)
        return img

    def __len__(self):
        return len(self._images)
    def __getitem__(self, index):
        if index &lt; 0 or index &gt;= len(self):
            raise IndexError(&#39;Index %s out of range.&#39; % (index))
        return self._images[index]
    def __iter__(self):
        return self._images.__iter__()

__DEFAULT_EXTENSIONS = {&#39;tiff&#39; : &#39;.tiff&#39;,
                        &#39;worldview&#39; : &#39;.zip&#39;,
                        &#39;landsat&#39; : &#39;.zip&#39;,
                        &#39;npy&#39; : &#39;.npy&#39;,
                        &#39;sentinel1&#39; : &#39;.zip&#39;}

def __extension(conf):
    if conf[&#39;extension&#39;] == &#39;default&#39;:
        return __DEFAULT_EXTENSIONS.get(conf[&#39;type&#39;])
    return conf[&#39;extension&#39;]

def __find_images(conf, matching_images=None, matching_conf=None):
    &#39;&#39;&#39;
    Find the images specified by a given configuration, returning a list of images.
    If matching_images and matching_conf are specified, we find the labels matching these images.
    &#39;&#39;&#39;
    images = []
    if conf[&#39;type&#39;] not in __DEFAULT_EXTENSIONS:
        raise ValueError(&#39;Unexpected image type %s.&#39; % (conf[&#39;type&#39;]))

    if conf[&#39;files&#39;]:
        assert conf[&#39;file_list&#39;] is None and conf[&#39;directory&#39;] is None, &#39;Only one image specification allowed.&#39;
        images = conf[&#39;files&#39;]
        for (i, im) in enumerate(images):
            images[i] = os.path.normpath(im)
    elif conf[&#39;file_list&#39;]:
        assert conf[&#39;directory&#39;] is None, &#39;Only one image specification allowed.&#39;
        with open(conf[&#39;file_list&#39;], &#39;r&#39;) as f:
            for line in f:
                images.append(os.path.normpath(line.strip()))
    elif conf[&#39;directory&#39;]:
        extension = __extension(conf)
        if not os.path.exists(conf[&#39;directory&#39;]):
            raise ValueError(&#39;Supplied images directory %s does not exist.&#39; % (conf[&#39;directory&#39;]))
        if matching_images is None:
            for root, _, filenames in os.walk(conf[&#39;directory&#39;],
                                              followlinks=True):
                for filename in filenames:
                    if filename.endswith(extension):
                        images.append(os.path.join(root, filename))
        else:
            # find matching labels
            for m in matching_images:
                rel_path   = os.path.relpath(m, matching_conf[&#39;directory&#39;])
                label_path = os.path.join(conf[&#39;directory&#39;], rel_path)
                if matching_conf[&#39;directory&#39;] is None:
                    images.append(os.path.splitext(label_path)[0] + extension)
                else:
                    # if custom extension, remove it
                    label_path = label_path[:-len(__extension(matching_conf))]
                    images.append(label_path + extension)

    for img in images:
        if not os.path.exists(img):
            raise ValueError(&#39;Image file %s does not exist.&#39; % (img))
    return images

def load_images_labels(images_comp, labels_comp, classes_comp):
    &#39;&#39;&#39;
    Takes two configuration subsections and returns (image set, label set). Also takes classes
    configuration to apply preprocessing function to labels.
    &#39;&#39;&#39;
    images_dict = images_comp._config_dict #pylint:disable=protected-access
    labels_dict = labels_comp._config_dict #pylint:disable=protected-access
    images = __find_images(images_dict)

    if images_dict[&#39;directory&#39;]:
        if labels_dict[&#39;files&#39;] or labels_dict[&#39;file_list&#39;]:
            raise ValueError(&#39;Image directory only supported with label directory.&#39;)
        if labels_dict[&#39;directory&#39;]:
            # remove images in same directory ending with label&#39;s extension (can have .tiff and _label.tiff in same dir)
            if os.path.realpath(labels_dict[&#39;directory&#39;]).startswith(os.path.realpath(images_dict[&#39;directory&#39;])):
                label_extension = __extension(labels_dict)
                images = [img for img in images if not img.endswith(label_extension)]

    pre = images_comp.preprocess_function()
    imageset = ImageSet(images, images_dict[&#39;type&#39;], pre, images_dict[&#39;nodata_value&#39;])

    if (labels_dict[&#39;files&#39;] is None) and (labels_dict[&#39;file_list&#39;] is None) and (labels_dict[&#39;directory&#39;] is None):
        return (imageset, None)

    labels = __find_images(labels_dict, images, images_dict)

    if len(labels) != len(images):
        raise ValueError(&#39;%d images found, but %d labels found.&#39; % (len(images), len(labels)))

    labels_nodata = labels_dict[&#39;nodata_value&#39;]
    pre_orig = labels_comp.preprocess_function()
    # we shift the label images to always be 0...n[+1], Class 1, Class 2, ... Class N, [nodata]
    def class_shift(data, _, dummy):
        if pre_orig is not None:
            data = pre_orig(data, _, dummy)
        # set any nodata values to be past the expected range
        if labels_nodata is not None:
            nodata_indices = (data == labels_nodata)
        conv = classes_comp.classes_to_indices_func()
        if conv is not None:
            data = conv(data)
        if labels_nodata is not None:
            data[nodata_indices] = len(classes_comp)
        return data
    return (imageset, ImageSet(labels, labels_dict[&#39;type&#39;],
                               class_shift, len(classes_comp) if labels_nodata is not None else None))

class ImagePreprocessConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for image preprocessing.

    Expects a list of preprocessing functions registered
    with `delta.config.extensions.register_preprocess`.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._functions = []

    def _load_dict(self, d, base_dir):
        if d is None:
            self._functions = []
            return
        if not d:
            return
        self._functions = []
        assert isinstance(d, list), &#39;preprocess should be list of commands&#39;
        for func in d:
            if isinstance(func, str):
                self._functions.append((func, {}))
            else:
                assert isinstance(func, dict), &#39;preprocess items must be strings or dicts&#39;
                assert len(func) == 1, &#39;One preprocess item per list entry.&#39;
                name = list(func.keys())[0]
                self._functions.append((name, func[name]))

    def function(self, image_type):
        &#34;&#34;&#34;
        Parameters
        ----------
        image_type: str
            Type of the image
        Returns
        -------
        Callable:
            The specified preprocessing function to apply to the image.
        &#34;&#34;&#34;
        prep = lambda data, _, dummy: data
        for (name, args) in self._functions:
            t = preprocess_function(name)
            assert t is not None, &#39;Preprocess function %s not found.&#39; % (name)
            p = t(image_type=image_type, **args)
            def helper(cur, prev):
                return lambda data, roi, bands: cur(prev(data, roi, bands), roi, bands)
            prep = helper(p, prep)
        return prep

def _validate_paths(paths, base_dir):
    out = []
    for p in paths:
        out.append(validate_path(p, base_dir))
    return out

class ImageSetConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for a set of images.

    Used for images, labels, and validation images and labels.
    &#34;&#34;&#34;
    def __init__(self, name=None):
        super().__init__()
        self.register_field(&#39;type&#39;, str, &#39;type&#39;, None, &#39;Image type.&#39;)
        self.register_field(&#39;files&#39;, list, None, _validate_paths, &#39;List of image files.&#39;)
        self.register_field(&#39;file_list&#39;, str, None, validate_path, &#39;File listing image files.&#39;)
        self.register_field(&#39;directory&#39;, str, None, validate_path, &#39;Directory of image files.&#39;)
        self.register_field(&#39;extension&#39;, str, None, None, &#39;Image file extension.&#39;)
        self.register_field(&#39;nodata_value&#39;, (float, int), None, None, &#39;Value of pixels to ignore.&#39;)

        if name:
            self.register_arg(&#39;type&#39;, &#39;--&#39; + name + &#39;-type&#39;, name + &#39;_type&#39;)
            self.register_arg(&#39;file_list&#39;, &#39;--&#39; + name + &#39;-file-list&#39;, name + &#39;_file_list&#39;)
            self.register_arg(&#39;directory&#39;, &#39;--&#39; + name + &#39;-dir&#39;, name + &#39;_directory&#39;)
            self.register_arg(&#39;extension&#39;, &#39;--&#39; + name + &#39;-extension&#39;, name + &#39;_extension&#39;)
        self.register_component(ImagePreprocessConfig(), &#39;preprocess&#39;)
        self._name = name

    def preprocess_function(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable:
            Preprocessing function for the set of images.
        &#34;&#34;&#34;
        return self._components[&#39;preprocess&#39;].function(self._config_dict[&#39;type&#39;])

    def setup_arg_parser(self, parser, components = None) -&gt; None:
        if self._name is None:
            return
        super().setup_arg_parser(parser, components)
        parser.add_argument(&#34;--&#34; + self._name, dest=self._name, required=False,
                            help=&#34;Specify a single image file.&#34;)

    def parse_args(self, options):
        if self._name is None:
            return
        super().parse_args(options)
        if hasattr(options, self._name) and getattr(options, self._name) is not None:
            self._config_dict[&#39;files&#39;] = [getattr(options, self._name)]
            self._config_dict[&#39;directory&#39;] = None
            self._config_dict[&#39;file_list&#39;] = None

class LabelClass:
    &#34;&#34;&#34;
    Label configuration.
    &#34;&#34;&#34;
    def __init__(self, value, name=None, color=None, weight=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        value: int
            Pixel of the label
        name: str
            Name of the class to display
        color: int
            In visualizations, set the class to this RGB color.
        weight: float
            During training weight this class by this amount.
        &#34;&#34;&#34;
        color_order = [0x1f77b4, 0xff7f0e, 0x2ca02c, 0xd62728, 0x9467bd, 0x8c564b, \
                       0xe377c2, 0x7f7f7f, 0xbcbd22, 0x17becf]
        if name is None:
            name = &#39;Class &#39; + str(value)
        if color is None:
            color = color_order[value] if value &lt; len(color_order) else 0
        self.value = value
        self.name = name
        self.color = color
        self.weight = weight
        self.end_value = None

    def __repr__(self):
        return &#39;Color: &#39; + self.name

class ClassesConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for classes.

    Specify either a number of classes or list of classes with details.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._classes = []
        self._conversions = []

    def __iter__(self):
        return self._classes.__iter__()

    def __getitem__(self, key):
        return self._classes[key]

    def __len__(self):
        return len(self._classes)

    # overwrite model entirely if updated (don&#39;t want combined layers from multiple files)
    def _load_dict(self, d : dict, base_dir):
        if not d:
            return
        self._config_dict = d
        self._classes = []
        if isinstance(d, int):
            for i in range(d):
                self._classes.append(LabelClass(i))
        elif isinstance(d, list):
            for (i, c) in enumerate(d):
                if isinstance(c, int): # just pixel value
                    self._classes.append(LabelClass(i))
                else:
                    keys = c.keys()
                    assert len(keys) == 1, &#39;Dict should have name of pixel value.&#39;
                    k = next(iter(keys))
                    assert isinstance(k, int), &#39;Class label value must be int.&#39;
                    inner_dict = c[k]
                    self._classes.append(LabelClass(k, str(inner_dict.get(&#39;name&#39;)),
                                                    inner_dict.get(&#39;color&#39;), inner_dict.get(&#39;weight&#39;)))
        elif isinstance(d, dict):
            for k in d:
                assert isinstance(k, int), &#39;Class label value must be int.&#39;
                self._classes.append(LabelClass(k, str(d[k].get(&#39;name&#39;)),
                                                d[k].get(&#39;color&#39;), d[k].get(&#39;weight&#39;)))
        else:
            raise ValueError(&#39;Expected classes to be an int or list in config, was &#39; + str(d))
        # make sure the order is consistent for same values, and create preprocessing function
        self._conversions = []
        self._classes = sorted(self._classes, key=lambda x: x.value)
        for (i, v) in enumerate(self._classes):
            if v.value != i:
                self._conversions.append(v.value)
            v.end_value = i

    def class_id(self, class_name):
        &#34;&#34;&#34;
        Parameters
        ----------
        class_name: int or str
            Either the original pixel value in images (int) or the name (str) of a class.
            The special value &#39;nodata&#39; will give the nodata class, if any.

        Returns
        -------
        int:
            the ID of the class in the labels after default image preprocessing (labels are arranged
            to a canonical order, with nodata always coming after them.)
        &#34;&#34;&#34;
        if class_name == len(self._classes) or class_name == &#39;nodata&#39;:
            return len(self._classes)
        for (i, c) in enumerate(self._classes):
            if class_name in (c.value, c.name):
                return i
        raise ValueError(&#39;Class &#39; + str(class_name) + &#39; not found.&#39;)

    def weights(self):
        &#34;&#34;&#34;
        Returns
        -------
        List[float]
            List of class weights for use in training, if specified.
        &#34;&#34;&#34;
        weights = []
        for c in self._classes:
            if c.weight is not None:
                weights.append(c.weight)
        if not weights:
            return None
        assert len(weights) == len(self._classes), &#39;For class weights, either all or none must be specified.&#39;
        return weights

    def classes_to_indices_func(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable[[numpy.ndarray], numpy.ndarray]:
            Function to convert label image to canonical form
        &#34;&#34;&#34;
        if not self._conversions:
            return None
        def convert(data):
            assert isinstance(data, np.ndarray)
            for (i, c) in enumerate(self._conversions):
                data[data == c] = i
            return data
        return convert

    def indices_to_classes_func(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable[[numpy.ndarray], numpy.ndarray]:
            Reverse of `classes_to_indices_func`.
        &#34;&#34;&#34;
        if not self._conversions:
            return None
        def convert(data):
            assert isinstance(data, np.ndarray)
            for (i, c) in reversed(list(enumerate(self._conversions))):
                data[data == i] = c
            return data
        return convert

class DatasetConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for a dataset.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;Dataset&#39;)
        self.register_component(ImageSetConfig(&#39;image&#39;), &#39;images&#39;, &#39;__image_comp&#39;)
        self.register_component(ImageSetConfig(&#39;label&#39;), &#39;labels&#39;, &#39;__label_comp&#39;)
        self.__images = None
        self.__labels = None
        self.register_component(ClassesConfig(), &#39;classes&#39;)

    def reset(self):
        super().reset()
        self.__images = None
        self.__labels = None

    def images(self) -&gt; ImageSet:
        &#34;&#34;&#34;
        Returns
        -------
        ImageSet:
            the training images
        &#34;&#34;&#34;
        if self.__images is None:
            (self.__images, self.__labels) = load_images_labels(self._components[&#39;images&#39;],
                                                                self._components[&#39;labels&#39;],
                                                                self._components[&#39;classes&#39;])
        return self.__images

    def labels(self) -&gt; ImageSet:
        &#34;&#34;&#34;
        Returns
        -------
        ImageSet:
            the label images
        &#34;&#34;&#34;
        if self.__labels is None:
            (self.__images, self.__labels) = load_images_labels(self._components[&#39;images&#39;],
                                                                self._components[&#39;labels&#39;],
                                                                self._components[&#39;classes&#39;])
        return self.__labels

class CacheConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for cache.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self.register_field(&#39;dir&#39;, str, None, validate_path, &#39;Cache directory.&#39;)
        self.register_field(&#39;limit&#39;, int, None, validate_positive, &#39;Number of items to cache.&#39;)

        self._cache_manager = None

    def reset(self):
        super().reset()
        self._cache_manager = None

    def manager(self) -&gt; disk_folder_cache.DiskCache:
        &#34;&#34;&#34;
        Returns
        -------
        `disk_folder_cache.DiskCache`:
            the object to manage the cache
        &#34;&#34;&#34;
        if self._cache_manager is None:
            # Auto-populating defaults here is a workaround so small tools can skip the full
            # command line config setup.  Could be improved!
            if &#39;dir&#39; not in self._config_dict:
                self._config_dict[&#39;dir&#39;] = &#39;default&#39;
            if &#39;limit&#39; not in self._config_dict:
                self._config_dict[&#39;limit&#39;] = 8
            cdir = self._config_dict[&#39;dir&#39;]
            if cdir == &#39;default&#39;:
                cdir = appdirs.AppDirs(&#39;delta&#39;, &#39;nasa&#39;).user_cache_dir
            self._cache_manager = disk_folder_cache.DiskCache(cdir, self._config_dict[&#39;limit&#39;])
        return self._cache_manager

def _validate_tile_size(size, _):
    assert len(size) == 2, &#39;Size must have two components.&#39;
    assert isinstance(size[0], int) and isinstance(size[1], int), &#39;Size must be integer.&#39;
    assert size[0] &gt; 0 and size[1] &gt; 1, &#39;Size must be positive.&#39;
    return size

class IOConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for I/O.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;IO&#39;)
        self.register_field(&#39;threads&#39;, int, None, None, &#39;Number of threads to use.&#39;)
        self.register_field(&#39;tile_size&#39;, list, &#39;tile_size&#39;, _validate_tile_size,
                            &#39;Size of an image tile to load in memory at once.&#39;)
        self.register_field(&#39;interleave_blocks&#39;, int, &#39;interleave_blocks&#39;, None,
                            &#39;Number of blocks to interleave at a time.&#39;)

        self.register_arg(&#39;threads&#39;, &#39;--threads&#39;)

        self.register_component(CacheConfig(), &#39;cache&#39;)

    def threads(self):
        &#34;&#34;&#34;
        Returns
        -------
        int:
            number of threads to use for I/O
        &#34;&#34;&#34;
        if &#39;threads&#39; in self._config_dict and self._config_dict[&#39;threads&#39;]:
            return self._config_dict[&#39;threads&#39;]
        return min(1, os.cpu_count() // 2)

def register():
    &#34;&#34;&#34;
    Registers imagery config options with the global config manager.

    cmd_args enables command line options if set to true.
    &#34;&#34;&#34;
    config.register_component(DatasetConfig(), &#39;dataset&#39;)
    config.register_component(IOConfig(), &#39;io&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="delta.imagery.imagery_config.load_images_labels"><code class="name flex">
<span>def <span class="ident">load_images_labels</span></span>(<span>images_comp, labels_comp, classes_comp)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes two configuration subsections and returns (image set, label set). Also takes classes
configuration to apply preprocessing function to labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images_labels(images_comp, labels_comp, classes_comp):
    &#39;&#39;&#39;
    Takes two configuration subsections and returns (image set, label set). Also takes classes
    configuration to apply preprocessing function to labels.
    &#39;&#39;&#39;
    images_dict = images_comp._config_dict #pylint:disable=protected-access
    labels_dict = labels_comp._config_dict #pylint:disable=protected-access
    images = __find_images(images_dict)

    if images_dict[&#39;directory&#39;]:
        if labels_dict[&#39;files&#39;] or labels_dict[&#39;file_list&#39;]:
            raise ValueError(&#39;Image directory only supported with label directory.&#39;)
        if labels_dict[&#39;directory&#39;]:
            # remove images in same directory ending with label&#39;s extension (can have .tiff and _label.tiff in same dir)
            if os.path.realpath(labels_dict[&#39;directory&#39;]).startswith(os.path.realpath(images_dict[&#39;directory&#39;])):
                label_extension = __extension(labels_dict)
                images = [img for img in images if not img.endswith(label_extension)]

    pre = images_comp.preprocess_function()
    imageset = ImageSet(images, images_dict[&#39;type&#39;], pre, images_dict[&#39;nodata_value&#39;])

    if (labels_dict[&#39;files&#39;] is None) and (labels_dict[&#39;file_list&#39;] is None) and (labels_dict[&#39;directory&#39;] is None):
        return (imageset, None)

    labels = __find_images(labels_dict, images, images_dict)

    if len(labels) != len(images):
        raise ValueError(&#39;%d images found, but %d labels found.&#39; % (len(images), len(labels)))

    labels_nodata = labels_dict[&#39;nodata_value&#39;]
    pre_orig = labels_comp.preprocess_function()
    # we shift the label images to always be 0...n[+1], Class 1, Class 2, ... Class N, [nodata]
    def class_shift(data, _, dummy):
        if pre_orig is not None:
            data = pre_orig(data, _, dummy)
        # set any nodata values to be past the expected range
        if labels_nodata is not None:
            nodata_indices = (data == labels_nodata)
        conv = classes_comp.classes_to_indices_func()
        if conv is not None:
            data = conv(data)
        if labels_nodata is not None:
            data[nodata_indices] = len(classes_comp)
        return data
    return (imageset, ImageSet(labels, labels_dict[&#39;type&#39;],
                               class_shift, len(classes_comp) if labels_nodata is not None else None))</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers imagery config options with the global config manager.</p>
<p>cmd_args enables command line options if set to true.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register():
    &#34;&#34;&#34;
    Registers imagery config options with the global config manager.

    cmd_args enables command line options if set to true.
    &#34;&#34;&#34;
    config.register_component(DatasetConfig(), &#39;dataset&#39;)
    config.register_component(IOConfig(), &#39;io&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="delta.imagery.imagery_config.CacheConfig"><code class="flex name class">
<span>class <span class="ident">CacheConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Configuration for cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section_header</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The title of the section for command line arguments in the help.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CacheConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for cache.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self.register_field(&#39;dir&#39;, str, None, validate_path, &#39;Cache directory.&#39;)
        self.register_field(&#39;limit&#39;, int, None, validate_positive, &#39;Number of items to cache.&#39;)

        self._cache_manager = None

    def reset(self):
        super().reset()
        self._cache_manager = None

    def manager(self) -&gt; disk_folder_cache.DiskCache:
        &#34;&#34;&#34;
        Returns
        -------
        `disk_folder_cache.DiskCache`:
            the object to manage the cache
        &#34;&#34;&#34;
        if self._cache_manager is None:
            # Auto-populating defaults here is a workaround so small tools can skip the full
            # command line config setup.  Could be improved!
            if &#39;dir&#39; not in self._config_dict:
                self._config_dict[&#39;dir&#39;] = &#39;default&#39;
            if &#39;limit&#39; not in self._config_dict:
                self._config_dict[&#39;limit&#39;] = 8
            cdir = self._config_dict[&#39;dir&#39;]
            if cdir == &#39;default&#39;:
                cdir = appdirs.AppDirs(&#39;delta&#39;, &#39;nasa&#39;).user_cache_dir
            self._cache_manager = disk_folder_cache.DiskCache(cdir, self._config_dict[&#39;limit&#39;])
        return self._cache_manager</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.CacheConfig.manager"><code class="name flex">
<span>def <span class="ident">manager</span></span>(<span>self) â>Â <a title="delta.imagery.disk_folder_cache.DiskCache" href="disk_folder_cache.html#delta.imagery.disk_folder_cache.DiskCache">DiskCache</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p><code>disk_folder_cache.DiskCache</code>:
the object to manage the cache</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manager(self) -&gt; disk_folder_cache.DiskCache:
    &#34;&#34;&#34;
    Returns
    -------
    `disk_folder_cache.DiskCache`:
        the object to manage the cache
    &#34;&#34;&#34;
    if self._cache_manager is None:
        # Auto-populating defaults here is a workaround so small tools can skip the full
        # command line config setup.  Could be improved!
        if &#39;dir&#39; not in self._config_dict:
            self._config_dict[&#39;dir&#39;] = &#39;default&#39;
        if &#39;limit&#39; not in self._config_dict:
            self._config_dict[&#39;limit&#39;] = 8
        cdir = self._config_dict[&#39;dir&#39;]
        if cdir == &#39;default&#39;:
            cdir = appdirs.AppDirs(&#39;delta&#39;, &#39;nasa&#39;).user_cache_dir
        self._cache_manager = disk_folder_cache.DiskCache(cdir, self._config_dict[&#39;limit&#39;])
    return self._cache_manager</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="../config/config.html#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="../config/config.html#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="../config/config.html#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="../config/config.html#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="../config/config.html#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.imagery.imagery_config.ClassesConfig"><code class="flex name class">
<span>class <span class="ident">ClassesConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Configuration for classes.</p>
<p>Specify either a number of classes or list of classes with details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section_header</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The title of the section for command line arguments in the help.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClassesConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for classes.

    Specify either a number of classes or list of classes with details.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._classes = []
        self._conversions = []

    def __iter__(self):
        return self._classes.__iter__()

    def __getitem__(self, key):
        return self._classes[key]

    def __len__(self):
        return len(self._classes)

    # overwrite model entirely if updated (don&#39;t want combined layers from multiple files)
    def _load_dict(self, d : dict, base_dir):
        if not d:
            return
        self._config_dict = d
        self._classes = []
        if isinstance(d, int):
            for i in range(d):
                self._classes.append(LabelClass(i))
        elif isinstance(d, list):
            for (i, c) in enumerate(d):
                if isinstance(c, int): # just pixel value
                    self._classes.append(LabelClass(i))
                else:
                    keys = c.keys()
                    assert len(keys) == 1, &#39;Dict should have name of pixel value.&#39;
                    k = next(iter(keys))
                    assert isinstance(k, int), &#39;Class label value must be int.&#39;
                    inner_dict = c[k]
                    self._classes.append(LabelClass(k, str(inner_dict.get(&#39;name&#39;)),
                                                    inner_dict.get(&#39;color&#39;), inner_dict.get(&#39;weight&#39;)))
        elif isinstance(d, dict):
            for k in d:
                assert isinstance(k, int), &#39;Class label value must be int.&#39;
                self._classes.append(LabelClass(k, str(d[k].get(&#39;name&#39;)),
                                                d[k].get(&#39;color&#39;), d[k].get(&#39;weight&#39;)))
        else:
            raise ValueError(&#39;Expected classes to be an int or list in config, was &#39; + str(d))
        # make sure the order is consistent for same values, and create preprocessing function
        self._conversions = []
        self._classes = sorted(self._classes, key=lambda x: x.value)
        for (i, v) in enumerate(self._classes):
            if v.value != i:
                self._conversions.append(v.value)
            v.end_value = i

    def class_id(self, class_name):
        &#34;&#34;&#34;
        Parameters
        ----------
        class_name: int or str
            Either the original pixel value in images (int) or the name (str) of a class.
            The special value &#39;nodata&#39; will give the nodata class, if any.

        Returns
        -------
        int:
            the ID of the class in the labels after default image preprocessing (labels are arranged
            to a canonical order, with nodata always coming after them.)
        &#34;&#34;&#34;
        if class_name == len(self._classes) or class_name == &#39;nodata&#39;:
            return len(self._classes)
        for (i, c) in enumerate(self._classes):
            if class_name in (c.value, c.name):
                return i
        raise ValueError(&#39;Class &#39; + str(class_name) + &#39; not found.&#39;)

    def weights(self):
        &#34;&#34;&#34;
        Returns
        -------
        List[float]
            List of class weights for use in training, if specified.
        &#34;&#34;&#34;
        weights = []
        for c in self._classes:
            if c.weight is not None:
                weights.append(c.weight)
        if not weights:
            return None
        assert len(weights) == len(self._classes), &#39;For class weights, either all or none must be specified.&#39;
        return weights

    def classes_to_indices_func(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable[[numpy.ndarray], numpy.ndarray]:
            Function to convert label image to canonical form
        &#34;&#34;&#34;
        if not self._conversions:
            return None
        def convert(data):
            assert isinstance(data, np.ndarray)
            for (i, c) in enumerate(self._conversions):
                data[data == c] = i
            return data
        return convert

    def indices_to_classes_func(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable[[numpy.ndarray], numpy.ndarray]:
            Reverse of `classes_to_indices_func`.
        &#34;&#34;&#34;
        if not self._conversions:
            return None
        def convert(data):
            assert isinstance(data, np.ndarray)
            for (i, c) in reversed(list(enumerate(self._conversions))):
                data[data == i] = c
            return data
        return convert</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.ClassesConfig.class_id"><code class="name flex">
<span>def <span class="ident">class_id</span></span>(<span>self, class_name)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>class_name</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Either the original pixel value in images (int) or the name (str) of a class.
The special value 'nodata' will give the nodata class, if any.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>the ID of the class in the labels after default image preprocessing (labels are arranged
to a canonical order, with nodata always coming after them.)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def class_id(self, class_name):
    &#34;&#34;&#34;
    Parameters
    ----------
    class_name: int or str
        Either the original pixel value in images (int) or the name (str) of a class.
        The special value &#39;nodata&#39; will give the nodata class, if any.

    Returns
    -------
    int:
        the ID of the class in the labels after default image preprocessing (labels are arranged
        to a canonical order, with nodata always coming after them.)
    &#34;&#34;&#34;
    if class_name == len(self._classes) or class_name == &#39;nodata&#39;:
        return len(self._classes)
    for (i, c) in enumerate(self._classes):
        if class_name in (c.value, c.name):
            return i
    raise ValueError(&#39;Class &#39; + str(class_name) + &#39; not found.&#39;)</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ClassesConfig.classes_to_indices_func"><code class="name flex">
<span>def <span class="ident">classes_to_indices_func</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[numpy.ndarray], numpy.ndarray]:</code></dt>
<dd>Function to convert label image to canonical form</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classes_to_indices_func(self):
    &#34;&#34;&#34;
    Returns
    -------
    Callable[[numpy.ndarray], numpy.ndarray]:
        Function to convert label image to canonical form
    &#34;&#34;&#34;
    if not self._conversions:
        return None
    def convert(data):
        assert isinstance(data, np.ndarray)
        for (i, c) in enumerate(self._conversions):
            data[data == c] = i
        return data
    return convert</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ClassesConfig.indices_to_classes_func"><code class="name flex">
<span>def <span class="ident">indices_to_classes_func</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[numpy.ndarray], numpy.ndarray]:</code></dt>
<dd>Reverse of <code>classes_to_indices_func</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indices_to_classes_func(self):
    &#34;&#34;&#34;
    Returns
    -------
    Callable[[numpy.ndarray], numpy.ndarray]:
        Reverse of `classes_to_indices_func`.
    &#34;&#34;&#34;
    if not self._conversions:
        return None
    def convert(data):
        assert isinstance(data, np.ndarray)
        for (i, c) in reversed(list(enumerate(self._conversions))):
            data[data == i] = c
        return data
    return convert</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ClassesConfig.weights"><code class="name flex">
<span>def <span class="ident">weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>List[float]</code></dt>
<dd>List of class weights for use in training, if specified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weights(self):
    &#34;&#34;&#34;
    Returns
    -------
    List[float]
        List of class weights for use in training, if specified.
    &#34;&#34;&#34;
    weights = []
    for c in self._classes:
        if c.weight is not None:
            weights.append(c.weight)
    if not weights:
        return None
    assert len(weights) == len(self._classes), &#39;For class weights, either all or none must be specified.&#39;
    return weights</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="../config/config.html#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="../config/config.html#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="../config/config.html#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="../config/config.html#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="../config/config.html#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.imagery.imagery_config.DatasetConfig"><code class="flex name class">
<span>class <span class="ident">DatasetConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Configuration for a dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section_header</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The title of the section for command line arguments in the help.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatasetConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for a dataset.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;Dataset&#39;)
        self.register_component(ImageSetConfig(&#39;image&#39;), &#39;images&#39;, &#39;__image_comp&#39;)
        self.register_component(ImageSetConfig(&#39;label&#39;), &#39;labels&#39;, &#39;__label_comp&#39;)
        self.__images = None
        self.__labels = None
        self.register_component(ClassesConfig(), &#39;classes&#39;)

    def reset(self):
        super().reset()
        self.__images = None
        self.__labels = None

    def images(self) -&gt; ImageSet:
        &#34;&#34;&#34;
        Returns
        -------
        ImageSet:
            the training images
        &#34;&#34;&#34;
        if self.__images is None:
            (self.__images, self.__labels) = load_images_labels(self._components[&#39;images&#39;],
                                                                self._components[&#39;labels&#39;],
                                                                self._components[&#39;classes&#39;])
        return self.__images

    def labels(self) -&gt; ImageSet:
        &#34;&#34;&#34;
        Returns
        -------
        ImageSet:
            the label images
        &#34;&#34;&#34;
        if self.__labels is None:
            (self.__images, self.__labels) = load_images_labels(self._components[&#39;images&#39;],
                                                                self._components[&#39;labels&#39;],
                                                                self._components[&#39;classes&#39;])
        return self.__labels</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.DatasetConfig.images"><code class="name flex">
<span>def <span class="ident">images</span></span>(<span>self) â>Â <a title="delta.imagery.imagery_config.ImageSet" href="#delta.imagery.imagery_config.ImageSet">ImageSet</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<h2 id="imageset">Imageset</h2>
<p>the training images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images(self) -&gt; ImageSet:
    &#34;&#34;&#34;
    Returns
    -------
    ImageSet:
        the training images
    &#34;&#34;&#34;
    if self.__images is None:
        (self.__images, self.__labels) = load_images_labels(self._components[&#39;images&#39;],
                                                            self._components[&#39;labels&#39;],
                                                            self._components[&#39;classes&#39;])
    return self.__images</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.DatasetConfig.labels"><code class="name flex">
<span>def <span class="ident">labels</span></span>(<span>self) â>Â <a title="delta.imagery.imagery_config.ImageSet" href="#delta.imagery.imagery_config.ImageSet">ImageSet</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<h2 id="imageset">Imageset</h2>
<p>the label images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def labels(self) -&gt; ImageSet:
    &#34;&#34;&#34;
    Returns
    -------
    ImageSet:
        the label images
    &#34;&#34;&#34;
    if self.__labels is None:
        (self.__images, self.__labels) = load_images_labels(self._components[&#39;images&#39;],
                                                            self._components[&#39;labels&#39;],
                                                            self._components[&#39;classes&#39;])
    return self.__labels</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="../config/config.html#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="../config/config.html#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="../config/config.html#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="../config/config.html#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="../config/config.html#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.imagery.imagery_config.IOConfig"><code class="flex name class">
<span>class <span class="ident">IOConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Configuration for I/O.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section_header</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The title of the section for command line arguments in the help.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IOConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for I/O.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;IO&#39;)
        self.register_field(&#39;threads&#39;, int, None, None, &#39;Number of threads to use.&#39;)
        self.register_field(&#39;tile_size&#39;, list, &#39;tile_size&#39;, _validate_tile_size,
                            &#39;Size of an image tile to load in memory at once.&#39;)
        self.register_field(&#39;interleave_blocks&#39;, int, &#39;interleave_blocks&#39;, None,
                            &#39;Number of blocks to interleave at a time.&#39;)

        self.register_arg(&#39;threads&#39;, &#39;--threads&#39;)

        self.register_component(CacheConfig(), &#39;cache&#39;)

    def threads(self):
        &#34;&#34;&#34;
        Returns
        -------
        int:
            number of threads to use for I/O
        &#34;&#34;&#34;
        if &#39;threads&#39; in self._config_dict and self._config_dict[&#39;threads&#39;]:
            return self._config_dict[&#39;threads&#39;]
        return min(1, os.cpu_count() // 2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.IOConfig.threads"><code class="name flex">
<span>def <span class="ident">threads</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>number of threads to use for I/O</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threads(self):
    &#34;&#34;&#34;
    Returns
    -------
    int:
        number of threads to use for I/O
    &#34;&#34;&#34;
    if &#39;threads&#39; in self._config_dict and self._config_dict[&#39;threads&#39;]:
        return self._config_dict[&#39;threads&#39;]
    return min(1, os.cpu_count() // 2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="../config/config.html#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="../config/config.html#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="../config/config.html#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="../config/config.html#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="../config/config.html#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.imagery.imagery_config.ImagePreprocessConfig"><code class="flex name class">
<span>class <span class="ident">ImagePreprocessConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Configuration for image preprocessing.</p>
<p>Expects a list of preprocessing functions registered
with <code><a title="delta.config.extensions.register_preprocess" href="../config/extensions.html#delta.config.extensions.register_preprocess">register_preprocess()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section_header</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The title of the section for command line arguments in the help.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImagePreprocessConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for image preprocessing.

    Expects a list of preprocessing functions registered
    with `delta.config.extensions.register_preprocess`.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._functions = []

    def _load_dict(self, d, base_dir):
        if d is None:
            self._functions = []
            return
        if not d:
            return
        self._functions = []
        assert isinstance(d, list), &#39;preprocess should be list of commands&#39;
        for func in d:
            if isinstance(func, str):
                self._functions.append((func, {}))
            else:
                assert isinstance(func, dict), &#39;preprocess items must be strings or dicts&#39;
                assert len(func) == 1, &#39;One preprocess item per list entry.&#39;
                name = list(func.keys())[0]
                self._functions.append((name, func[name]))

    def function(self, image_type):
        &#34;&#34;&#34;
        Parameters
        ----------
        image_type: str
            Type of the image
        Returns
        -------
        Callable:
            The specified preprocessing function to apply to the image.
        &#34;&#34;&#34;
        prep = lambda data, _, dummy: data
        for (name, args) in self._functions:
            t = preprocess_function(name)
            assert t is not None, &#39;Preprocess function %s not found.&#39; % (name)
            p = t(image_type=image_type, **args)
            def helper(cur, prev):
                return lambda data, roi, bands: cur(prev(data, roi, bands), roi, bands)
            prep = helper(p, prep)
        return prep</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.ImagePreprocessConfig.function"><code class="name flex">
<span>def <span class="ident">function</span></span>(<span>self, image_type)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the image</dd>
</dl>
<h2 id="returns">Returns</h2>
<h2 id="callable">Callable</h2>
<p>The specified preprocessing function to apply to the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function(self, image_type):
    &#34;&#34;&#34;
    Parameters
    ----------
    image_type: str
        Type of the image
    Returns
    -------
    Callable:
        The specified preprocessing function to apply to the image.
    &#34;&#34;&#34;
    prep = lambda data, _, dummy: data
    for (name, args) in self._functions:
        t = preprocess_function(name)
        assert t is not None, &#39;Preprocess function %s not found.&#39; % (name)
        p = t(image_type=image_type, **args)
        def helper(cur, prev):
            return lambda data, roi, bands: cur(prev(data, roi, bands), roi, bands)
        prep = helper(p, prep)
    return prep</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="../config/config.html#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="../config/config.html#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="../config/config.html#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="../config/config.html#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="../config/config.html#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.imagery.imagery_config.ImageSet"><code class="flex name class">
<span>class <span class="ident">ImageSet</span></span>
<span>(</span><span>images, image_type, preprocess=None, nodata_value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Specifies a set of image files.</p>
<p>The images can be accessed by using the <code><a title="delta.imagery.imagery_config.ImageSet" href="#delta.imagery.imagery_config.ImageSet">ImageSet</a></code> as an iterable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>Iterator[str]</code></dt>
<dd>Image filenames</dd>
<dt><strong><code>image_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The image type as a string (i.e., tiff, worldview, landsat). Must have
been previously registered with <code><a title="delta.config.extensions.register_image_reader" href="../config/extensions.html#delta.config.extensions.register_image_reader">register_image_reader()</a></code>.</dd>
<dt><strong><code>preprocess</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Optional preprocessing function to apply to the image
following the signature in <code><a title="delta.imagery.delta_image.DeltaImage.set_preprocess" href="delta_image.html#delta.imagery.delta_image.DeltaImage.set_preprocess">DeltaImage.set_preprocess()</a></code>.</dd>
<dt><strong><code>nodata_value</code></strong> :&ensp;<code>image dtype</code></dt>
<dd>A no data value for pixels to disregard</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageSet:
    &#34;&#34;&#34;
    Specifies a set of image files.

    The images can be accessed by using the `ImageSet` as an iterable.
    &#34;&#34;&#34;
    def __init__(self, images, image_type, preprocess=None, nodata_value=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        images: Iterator[str]
            Image filenames
        image_type: str
            The image type as a string (i.e., tiff, worldview, landsat). Must have
            been previously registered with `delta.config.extensions.register_image_reader`.
        preprocess: Callable
            Optional preprocessing function to apply to the image
            following the signature in `delta.imagery.delta_image.DeltaImage.set_preprocess`.
        nodata_value: image dtype
            A no data value for pixels to disregard
        &#34;&#34;&#34;
        self._images = images
        self._image_type = image_type
        self._preprocess = preprocess
        self._nodata_value = nodata_value

    def type(self):
        &#34;&#34;&#34;
        Returns
        -------
        str:
            The type of the image
        &#34;&#34;&#34;
        return self._image_type
    def preprocess(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable:
            The preprocessing function
        &#34;&#34;&#34;
        return self._preprocess
    def nodata_value(self):
        &#34;&#34;&#34;
        Returns
        -------
        image dtype:
            Value of pixels to disregard.
        &#34;&#34;&#34;
        return self._nodata_value

    def set_nodata_value(self, nodata):
        &#34;&#34;&#34;
        Set the pixel value to disregard.

        Parameters
        ----------
        nodata: image dtype
            The pixel value to set as nodata
        &#34;&#34;&#34;
        self._nodata_value = nodata

    def load(self, index):
        &#34;&#34;&#34;
        Loads the image of the given index.

        Parameters
        ----------
        index: int
            Index of the image to load.

        Returns
        -------
        `delta.imagery.delta_image.DeltaImage`:
            The image
        &#34;&#34;&#34;
        img = image_reader(self.type())(self[index], self.nodata_value())
        if self._preprocess:
            img.set_preprocess(self._preprocess)
        return img

    def __len__(self):
        return len(self._images)
    def __getitem__(self, index):
        if index &lt; 0 or index &gt;= len(self):
            raise IndexError(&#39;Index %s out of range.&#39; % (index))
        return self._images[index]
    def __iter__(self):
        return self._images.__iter__()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.ImageSet.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the image of the given index.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the image to load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="delta.imagery.delta_image.DeltaImage" href="delta_image.html#delta.imagery.delta_image.DeltaImage">DeltaImage</a></code>:
The image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, index):
    &#34;&#34;&#34;
    Loads the image of the given index.

    Parameters
    ----------
    index: int
        Index of the image to load.

    Returns
    -------
    `delta.imagery.delta_image.DeltaImage`:
        The image
    &#34;&#34;&#34;
    img = image_reader(self.type())(self[index], self.nodata_value())
    if self._preprocess:
        img.set_preprocess(self._preprocess)
    return img</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ImageSet.nodata_value"><code class="name flex">
<span>def <span class="ident">nodata_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>image dtype:</code></dt>
<dd>Value of pixels to disregard.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodata_value(self):
    &#34;&#34;&#34;
    Returns
    -------
    image dtype:
        Value of pixels to disregard.
    &#34;&#34;&#34;
    return self._nodata_value</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ImageSet.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<h2 id="callable">Callable</h2>
<p>The preprocessing function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess(self):
    &#34;&#34;&#34;
    Returns
    -------
    Callable:
        The preprocessing function
    &#34;&#34;&#34;
    return self._preprocess</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ImageSet.set_nodata_value"><code class="name flex">
<span>def <span class="ident">set_nodata_value</span></span>(<span>self, nodata)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the pixel value to disregard.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodata</code></strong> :&ensp;<code>image dtype</code></dt>
<dd>The pixel value to set as nodata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nodata_value(self, nodata):
    &#34;&#34;&#34;
    Set the pixel value to disregard.

    Parameters
    ----------
    nodata: image dtype
        The pixel value to set as nodata
    &#34;&#34;&#34;
    self._nodata_value = nodata</code></pre>
</details>
</dd>
<dt id="delta.imagery.imagery_config.ImageSet.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str:</code></dt>
<dd>The type of the image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self):
    &#34;&#34;&#34;
    Returns
    -------
    str:
        The type of the image
    &#34;&#34;&#34;
    return self._image_type</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="delta.imagery.imagery_config.ImageSetConfig"><code class="flex name class">
<span>class <span class="ident">ImageSetConfig</span></span>
<span>(</span><span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Configuration for a set of images.</p>
<p>Used for images, labels, and validation images and labels.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section_header</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The title of the section for command line arguments in the help.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageSetConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    Configuration for a set of images.

    Used for images, labels, and validation images and labels.
    &#34;&#34;&#34;
    def __init__(self, name=None):
        super().__init__()
        self.register_field(&#39;type&#39;, str, &#39;type&#39;, None, &#39;Image type.&#39;)
        self.register_field(&#39;files&#39;, list, None, _validate_paths, &#39;List of image files.&#39;)
        self.register_field(&#39;file_list&#39;, str, None, validate_path, &#39;File listing image files.&#39;)
        self.register_field(&#39;directory&#39;, str, None, validate_path, &#39;Directory of image files.&#39;)
        self.register_field(&#39;extension&#39;, str, None, None, &#39;Image file extension.&#39;)
        self.register_field(&#39;nodata_value&#39;, (float, int), None, None, &#39;Value of pixels to ignore.&#39;)

        if name:
            self.register_arg(&#39;type&#39;, &#39;--&#39; + name + &#39;-type&#39;, name + &#39;_type&#39;)
            self.register_arg(&#39;file_list&#39;, &#39;--&#39; + name + &#39;-file-list&#39;, name + &#39;_file_list&#39;)
            self.register_arg(&#39;directory&#39;, &#39;--&#39; + name + &#39;-dir&#39;, name + &#39;_directory&#39;)
            self.register_arg(&#39;extension&#39;, &#39;--&#39; + name + &#39;-extension&#39;, name + &#39;_extension&#39;)
        self.register_component(ImagePreprocessConfig(), &#39;preprocess&#39;)
        self._name = name

    def preprocess_function(self):
        &#34;&#34;&#34;
        Returns
        -------
        Callable:
            Preprocessing function for the set of images.
        &#34;&#34;&#34;
        return self._components[&#39;preprocess&#39;].function(self._config_dict[&#39;type&#39;])

    def setup_arg_parser(self, parser, components = None) -&gt; None:
        if self._name is None:
            return
        super().setup_arg_parser(parser, components)
        parser.add_argument(&#34;--&#34; + self._name, dest=self._name, required=False,
                            help=&#34;Specify a single image file.&#34;)

    def parse_args(self, options):
        if self._name is None:
            return
        super().parse_args(options)
        if hasattr(options, self._name) and getattr(options, self._name) is not None:
            self._config_dict[&#39;files&#39;] = [getattr(options, self._name)]
            self._config_dict[&#39;directory&#39;] = None
            self._config_dict[&#39;file_list&#39;] = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.imagery_config.ImageSetConfig.preprocess_function"><code class="name flex">
<span>def <span class="ident">preprocess_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<h2 id="callable">Callable</h2>
<p>Preprocessing function for the set of images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_function(self):
    &#34;&#34;&#34;
    Returns
    -------
    Callable:
        Preprocessing function for the set of images.
    &#34;&#34;&#34;
    return self._components[&#39;preprocess&#39;].function(self._config_dict[&#39;type&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="../config/config.html#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="../config/config.html#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="../config/config.html#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="../config/config.html#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="../config/config.html#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="../config/config.html#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="../config/config.html#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.imagery.imagery_config.LabelClass"><code class="flex name class">
<span>class <span class="ident">LabelClass</span></span>
<span>(</span><span>value, name=None, color=None, weight=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Label configuration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>Pixel of the label</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the class to display</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>int</code></dt>
<dd>In visualizations, set the class to this RGB color.</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>float</code></dt>
<dd>During training weight this class by this amount.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabelClass:
    &#34;&#34;&#34;
    Label configuration.
    &#34;&#34;&#34;
    def __init__(self, value, name=None, color=None, weight=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        value: int
            Pixel of the label
        name: str
            Name of the class to display
        color: int
            In visualizations, set the class to this RGB color.
        weight: float
            During training weight this class by this amount.
        &#34;&#34;&#34;
        color_order = [0x1f77b4, 0xff7f0e, 0x2ca02c, 0xd62728, 0x9467bd, 0x8c564b, \
                       0xe377c2, 0x7f7f7f, 0xbcbd22, 0x17becf]
        if name is None:
            name = &#39;Class &#39; + str(value)
        if color is None:
            color = color_order[value] if value &lt; len(color_order) else 0
        self.value = value
        self.name = name
        self.color = color
        self.weight = weight
        self.end_value = None

    def __repr__(self):
        return &#39;Color: &#39; + self.name</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="delta.imagery" href="index.html">delta.imagery</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.load_images_labels" href="#delta.imagery.imagery_config.load_images_labels">load_images_labels</a></code></li>
<li><code><a title="delta.imagery.imagery_config.register" href="#delta.imagery.imagery_config.register">register</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="delta.imagery.imagery_config.CacheConfig" href="#delta.imagery.imagery_config.CacheConfig">CacheConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.CacheConfig.manager" href="#delta.imagery.imagery_config.CacheConfig.manager">manager</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.ClassesConfig" href="#delta.imagery.imagery_config.ClassesConfig">ClassesConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.ClassesConfig.class_id" href="#delta.imagery.imagery_config.ClassesConfig.class_id">class_id</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ClassesConfig.classes_to_indices_func" href="#delta.imagery.imagery_config.ClassesConfig.classes_to_indices_func">classes_to_indices_func</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ClassesConfig.indices_to_classes_func" href="#delta.imagery.imagery_config.ClassesConfig.indices_to_classes_func">indices_to_classes_func</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ClassesConfig.weights" href="#delta.imagery.imagery_config.ClassesConfig.weights">weights</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.DatasetConfig" href="#delta.imagery.imagery_config.DatasetConfig">DatasetConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.DatasetConfig.images" href="#delta.imagery.imagery_config.DatasetConfig.images">images</a></code></li>
<li><code><a title="delta.imagery.imagery_config.DatasetConfig.labels" href="#delta.imagery.imagery_config.DatasetConfig.labels">labels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.IOConfig" href="#delta.imagery.imagery_config.IOConfig">IOConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.IOConfig.threads" href="#delta.imagery.imagery_config.IOConfig.threads">threads</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.ImagePreprocessConfig" href="#delta.imagery.imagery_config.ImagePreprocessConfig">ImagePreprocessConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.ImagePreprocessConfig.function" href="#delta.imagery.imagery_config.ImagePreprocessConfig.function">function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.ImageSet" href="#delta.imagery.imagery_config.ImageSet">ImageSet</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.ImageSet.load" href="#delta.imagery.imagery_config.ImageSet.load">load</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ImageSet.nodata_value" href="#delta.imagery.imagery_config.ImageSet.nodata_value">nodata_value</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ImageSet.preprocess" href="#delta.imagery.imagery_config.ImageSet.preprocess">preprocess</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ImageSet.set_nodata_value" href="#delta.imagery.imagery_config.ImageSet.set_nodata_value">set_nodata_value</a></code></li>
<li><code><a title="delta.imagery.imagery_config.ImageSet.type" href="#delta.imagery.imagery_config.ImageSet.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.ImageSetConfig" href="#delta.imagery.imagery_config.ImageSetConfig">ImageSetConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.imagery_config.ImageSetConfig.preprocess_function" href="#delta.imagery.imagery_config.ImageSetConfig.preprocess_function">preprocess_function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.imagery_config.LabelClass" href="#delta.imagery.imagery_config.LabelClass">LabelClass</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>